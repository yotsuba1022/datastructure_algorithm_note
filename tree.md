# 樹\(Tree\)

由邊和節點構成的資料結構, 節點通常就是儲存資料的實體.

```
     o  -> root node
    / \
   o   o
  / \   \
 o   o   o -> 這層都是葉節點
```

### 常見術語

根: 樹的頂端節點, 一棵樹只有一個根

邊: 節點到節點的連接

路徑: 沿著邊, 從一個節點走到另一個節點, 所經過的節點順序稱為路徑

父節點, 子節點

節點, 葉節點\(沒有子節點的節點\)

度: 一個節點所包含的子節點數

子樹

層: 從根開始到指定節點的層數, 也稱為高度或深度

走訪: 按照某個特定的順序存取節點

關鍵字: 節點物件域中的某個屬性, 用來識別節點物件

### 二元樹

#### 定義: 樹中的每個節點, 最多只能有兩個子節點

對二元樹的理解

1. 二元樹與樹的區別為:

   a. 樹中節點的子節點樹沒有限制, 而二元樹中限制節點數為不超過兩個

   b. 樹的節點沒有左右之分, 但二元樹的節點是分左右的

2. 二元樹有五種基本型態

   a. 空二元樹, 連根節點都沒有

   b. 只有一個根節點的二元樹

   c. 只有左樹

   d. 只有右樹

   e. 完全二元樹: 若設二元樹的高度為h, 除了第h層外, 其它各層的節點樹都達到最大個數,

   第h層有葉節點, 並且葉節點都是從左到右依次排序, 此即完全二元樹

3. 滿二元樹\(full\): 除了葉節點外, 每個節點都有左右子節點, 且葉節點都處在最底層

4. 滿二元樹必為完全二元樹, 完全二元樹不必然為滿二元樹

5. 二元樹常被用作二元搜尋樹, 二元排序樹, 二元堆

### 性質

性質1. 在二元樹的第i層上至多有2^\(i-1\)個節點

性質2. 深度為k的二元樹至多有\(2^k\)-1個節點

性質3. 對任何一顆二元樹T, 若其終端節點數量為n0, 度為2的節點數為n2, 則n0=n2+1

性質4. 具有N個節點的完全二元樹的深度為\[log2以N為底\]+1

性質5. 如果對一顆有n個節點的完全二元樹的節點按層序編號, 即從第1層到第\[log2以n為底\]+1層,

每層從左到右, 對任一節點i\(1 &lt;= i &lt;= n\)有:

a. 若i = 1, 則節點i是二元樹的根; 若i &gt; 1, 則其父節點是\[i/2\]

b. 若2i &gt; n, 則節點i無左子節點; 否則其左子節點是2i. 即該節點是葉節點

c. 若2i+1 &gt; n, 則節點i無右子節點; 否則其右子節點是2i+1

d. 若i為奇數且不小於1, 則Ki的左兄弟編號是i-1; 否則Ki無左兄弟

d. 若i為偶數且小於n, 則Ki的右兄弟編號是i+1; 否則Ki無右兄弟

### 二元搜尋樹\(Binary Search Tree, BST\)

#### 定義: 若一顆二元樹滿足以下兩點:

a. 左子節點的值小於節點的值

b. 右子節點的值大於節點的值

即可稱為二元搜尋樹

```
     2            6
    / \          / \
   1   3        5   8     <-----像這樣, 這兩棵都是BST
               /   / \
              3   7   9
```

二元搜尋樹的查詢, 插入, 走訪, 查詢最大最小值和刪除操作

提示: 刪除節點有兩個子節點的時候, 要用它的中序後繼來代替該節點,

**演算法為: 找到被刪除節點的右子節點, 然後查詢此右子節點下的最後一個左子節點, 即此顆子樹的最小值節點, 這就是被刪除節點的中序後繼節點.   **

何謂前序, 中序, 後序?

以上圖右邊的三層樹為例, 看1~2層的子樹:

前序: 6 -&gt; 5 -&gt; 8

中序: 5 -&gt; 6 -&gt; 8

後序: 5 -&gt; 8 -&gt; 6

若看整顆:

中序: 3 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 8 -&gt; 9

所以若要刪除8, 要找它的“中序後繼節點\(in-order successor\)”的話, 就是9了

### 二元搜尋樹操作的效率

#### 常見的時間複雜度為: O\(logN\), 是以2為底的

### 用陣列來表示樹

把樹的節點打上編號, 按順序放到陣列中. 如此一來, 查找節點就變成了查找相應的索引了. 這種方法不常用, 了解即可.

此種方式效率不高, 因為不滿的節點還有刪除的節點, 在陣列中留下了多餘的空間, 這是一種記憶體上的浪費, 更糟糕的是要刪除節點時, 若要移動子樹的話, 就更浪費時間了.





   

   

   

關於BST的實作, 可以看這裡\([點我](https://bitbucket.org/BlueLotus/my-leetcode/src/1e2c1dfabb062fead2f1a59fb2994b69034d54a5/src/main/java/idv/carl/datastructures/binarytree/BinaryTree.java?at=master&fileviewer=file-view-default)\)

以下是針對實作中的getSuccessor\(\)的部分做圖示說明

初始化:

```
             6

            / \

           5   8 deletedNode = successor = successorParent

          /   / \

         3   7   10 current = deletedNode.getRight\(\)

                / \

               9   11
```

```
// Find the node

             6

            / \

           5   8 successorParent = successor

          /   / \

         3   7   10 successor = current

                / \

               9   11

               ^---------- current = current.getLeft\(\)





             6

            / \

           5   8 deletedNode

          /   / \

         3   7   10 successorParent = successor

                / \

               9   11

               ^------- successor = current

                        current = current.getLeft\(\) = null



// Set related value

             6

            / \

           5   9 successor.setRight\(deletedNode.getRight\(\)\)

          /   / \

         3   7   10 successorParent.setLeft\(successor.getRight\(\)\)

                / \

              null 11                                          
```



